(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{252:function(t,e,r){"use strict";r.r(e);var a=r(0),n=Object(a.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"features"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#features","aria-hidden":"true"}},[t._v("#")]),t._v(" Features")]),t._v(" "),r("h2",{attrs:{id:"直接使用-flutter-会面临的问题？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#直接使用-flutter-会面临的问题？","aria-hidden":"true"}},[t._v("#")]),t._v(" 直接使用 flutter 会面临的问题？")]),t._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://github.com/flutter/flutter",target:"_blank",rel:"noopener noreferrer"}},[t._v("flutter"),r("OutboundLink")],1),t._v(" 是 google 推出的新一代跨平台渲染框架.\n它帮助开发者解决了跨平台，高性能，富有表现力和灵活的 UI 表达，快速开发等核心问题。\n但是如果开发大应用，还需要解决以下问题。")]),t._v(" "),r("blockquote",[r("ol",[r("li",[t._v("数据流问题")]),t._v(" "),r("li",[t._v("通信问题")]),t._v(" "),r("li",[t._v("可插拔的组件系统")]),t._v(" "),r("li",[t._v("展示和逻辑解耦")]),t._v(" "),r("li",[t._v("统一的编程模型和规范")])])]),t._v(" "),r("p",[t._v("我们可以类比 flutter 和 React，事实上在中大型应用中 React 会面临的绝大多数问题，flutter 也同样面临考验。")])]),t._v(" "),r("h2",{attrs:{id:"数据流问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据流问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 数据流问题")]),t._v(" "),r("blockquote",[r("p",[t._v("目前社区流行的数据流方案有：\n单向数据流方案，以 Redux 为代表\n响应式数据流方案，以 Mobx 为代表\n其他，以 rxjs 为代表\n那么哪一种架构最合适 flutter ？\n我们追随了 javascript 栈绝大多数开发者的选择 - "),r("a",{attrs:{href:"https://github.com/reduxjs/redux",target:"_blank",rel:"noopener noreferrer"}},[t._v("ReduxJs"),r("OutboundLink")],1),t._v("\n感谢 ReduxJs，我们是几乎 100%的还原了它在 dart 上的实现。所以我们也继承了它的优点：[Predictable],[Centralized],[Debuggable],[Flexible]。")])]),t._v(" "),r("h2",{attrs:{id:"通信问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#通信问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 通信问题")]),t._v(" "),r("blockquote",[r("p",[t._v("直接使用 flutter，在 Widgets 之间传递状态和回调，随着应用复杂度的上升，会变成是一件可怕而糟糕的事情。\n通过 fish redux，依托于集中的 Redux 和分治的 Effect 模块，通过一个极简的 "),r("router-link",{attrs:{to:"/en/guide/mechanism.html"}},[t._v("dispatch-api")]),t._v("，完成所有的通信的诉求。")],1)]),t._v(" "),r("h2",{attrs:{id:"可插拔的组件系统"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可插拔的组件系统","aria-hidden":"true"}},[t._v("#")]),t._v(" 可插拔的组件系统")]),t._v(" "),r("blockquote",[r("p",[t._v("fish redux 通过一个配置式的 Dependencies，来完成灵活的可插拔的组件系统。同时有这一配置的存在，它解放了我们手动拼装 Reducer 的繁琐工作。\n参考:")]),t._v(" "),r("blockquote",[r("ol",[r("li",[r("router-link",{attrs:{to:"/en/guide/what's-connector.html"}},[t._v("what's-connector")])],1),t._v(" "),r("li",[r("router-link",{attrs:{to:"/en/guide/connector.html"}},[t._v("connector")])],1),t._v(" "),r("li",[r("router-link",{attrs:{to:"/en/guide/dependencies.html"}},[t._v("dependencies")])],1),t._v(" "),r("li",[r("router-link",{attrs:{to:"/en/guide/component.html"}},[t._v("component")])],1),t._v(" "),r("li",[r("router-link",{attrs:{to:"/en/guide/adapter.html"}},[t._v("adapter")])],1),t._v(" "),r("li",[r("router-link",{attrs:{to:"/en/guide/what's-adapter.html"}},[t._v("what's-adapter")])],1)])])]),t._v(" "),r("h2",{attrs:{id:"展示和逻辑解耦"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#展示和逻辑解耦","aria-hidden":"true"}},[t._v("#")]),t._v(" 展示和逻辑解耦")]),t._v(" "),r("blockquote",[r("p",[t._v("fish redux 从 "),r("a",{attrs:{href:"https://guide.elm-lang.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("elm"),r("OutboundLink")],1),t._v(" 中得到了非常多的设计灵感。\n将一个组件，拆分为相互独立的 View，Effect，Reducer 三个函数，我们优雅的解决了展示和逻辑解耦的问题。\n通过这样的拆分，我们将 UI 的表达隔离于一个函数内，它让我们更好的面向未来，一份 UI 表达它可能来自于开发者，可能来自于深度学习框架的 UI 代码生成，可能是面向移动终端，也可能是面向浏览器。它让我们有了更多的组合的可能。\n同时函数式的编程模型带来了更容易编写，更容易扩展，更容易测试，更容易维护等特性。")])]),t._v(" "),r("h2",{attrs:{id:"统一的编程模型和规范"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#统一的编程模型和规范","aria-hidden":"true"}},[t._v("#")]),t._v(" 统一的编程模型和规范")]),t._v(" "),r("blockquote",[r("p",[r("router-link",{attrs:{to:"/en/guide/directory.html"}},[t._v("directory")])],1)])])},[],!1,null,null,null);e.default=n.exports}}]);